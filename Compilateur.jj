PARSER_BEGIN(Compilateur)
import AST.*;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.io.InputStream;

public class Compilateur {
    public static void main(String args[]) {
        try {
            //System.out.print("Tapez une Expression : ");
            FileInputStream fis = new FileInputStream("test.js");
            Compilateur parseur = new Compilateur(fis);
            Programme programme = parseur.mainNT(); // Changer pour Programme
            System.out.println("Assembly code  : \n" + programme.toAssembly()+"Halt"); // Modifier pour générer l'assembleur
            System.out.println("C'est bien une expression arithmétique !!");
        }catch (FileNotFoundException e) {
            System.out.println("Le fichier spécifié n'a pas été trouvé.");
        }catch (TokenMgrError e) {
            System.out.println("Ceci n'est pas une expression arithm\u00e9tique :"+e.toString());
        }catch (ParseException e){
            System.out.println("Ceci n'est pas une expression arithm\u00e9tique :"+e);
    }   }
}
PARSER_END(Compilateur)


TOKEN :
{
      < FLOAT: (("0" | ["1"-"9"] (["0"-"9"])* )? "." (["0"-"9"])+ (("E" | "e") ("+" | "-")? (["0"-"9"])+)? ) | (["0"-"9"])+ (("E" | "e") ("+" | "-")? (["0"-"9"])+)>
    | < NOMBRE: (["1"-"9"] (["0"-"9"])* | "0") (("E" | "e") ("+" | "-")? (["0"-"9"])+)?>
    | < BOOLEAN: "True" | "False">
    | < EOL: ";\n" | ";" >
    | < NAN: "NaN">
    | < IMPORT: "import">
    | < IDENT : (["a"-"z", "A"-"Z", "0"-"9", "/"])+ >
}
SKIP :
{ " " | "\t" | "\n" | < "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") > | < "/*" (~["*"])* "*" (~["/", "*"] (~["*"])* "*" )* "/" >}


Programme mainNT () :
{
    Programme prg;
}
{
    prg=programme() <EOF> { return prg; }


}
Programme programme() :
{
    List<Commande> programme = new ArrayList<>();
    Commande commande;
}
{
    (
        commande=commande() {

            programme.add(commande);

        }
    )*
    {
            return new Programme(programme);}

}
Commande commande() :
{
    Commande expr;
    Programme prg;
}
{
       expr=expression() <EOL> { return expr; }
     | <IMPORT> expr=facteur() <EOL> { return new Import(expr); }
     | "{" prg=programme() "}" {return new Bloc(prg);}

}



ExpressionA expression() :
{
    ExpressionA gauche, droite;
}
{
    gauche=comp() (
              "==" droite=comp()  { gauche = new Egal(gauche, droite); }
            | ">=" droite=comp()  { gauche = new GrEgNb(gauche, droite); }
            | ">"  droite=comp()  { gauche = new GrStNb(gauche, droite);}
            | "<"  droite=comp()  { gauche = new LoStNb(gauche, droite);}
            | "<=" droite=comp()  { gauche = new LoEqNb(gauche, droite); }
            | "!=" droite=comp()  { gauche = new NotEql(gauche, droite); }
            | "&&" droite=comp()  { gauche = new Et(gauche, droite); }
    )*
    { return gauche; }
}

ExpressionA comp() :
{
    ExpressionA gauche, droite;
}
{
    gauche=terme() (
         "+" droite=terme() { gauche = new Plus(gauche, droite); }
        | "-" droite=terme() { gauche = new Moins(gauche, droite); }
         )*
    { return gauche; }
}
ExpressionA terme () :
{
    ExpressionA gauche, droite;
}
{
    gauche=facteur() (
          "*" droite=facteur() { gauche = new Mult(gauche, droite); }
        | "/" droite=facteur() { gauche = new Div(gauche, droite);}
        | "%" droite=facteur() { gauche = new Modulo(gauche, droite); }
    )*
    { return gauche; }
}

ExpressionA facteur() :
{
    ExpressionA expr;
}
{
      "(" expr=expression() ")" { return expr; }
    | "-" expr=facteur() { return new Neg(expr); }
    | "!" expr=facteur() { return new Not(expr); }
    | <NOMBRE> { return new Num(Integer.parseInt(token.image));}
    | <FLOAT> { return new FloatT(Float.parseFloat(token.image));}
    | <BOOLEAN> { return new Bool(Boolean.parseBoolean(token.image));}// Construit un nœud Num
    | <IDENT> { return new Ident(token.image);}// Construit un nœud Num
}
